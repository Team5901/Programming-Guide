{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Programming Guide! This guide was written with several goals in mind: Allow students to learn programming independently One-stop location for programming resources Store programming knowledge for future Cougars If there are any mistakes, or anything is confusing please let me know. Kevin Hoang - Team 5901 Lead Mentor kkhoang.57@gmail.com","title":"Home"},{"location":"#welcome-to-the-programming-guide","text":"This guide was written with several goals in mind: Allow students to learn programming independently One-stop location for programming resources Store programming knowledge for future Cougars If there are any mistakes, or anything is confusing please let me know. Kevin Hoang - Team 5901 Lead Mentor kkhoang.57@gmail.com","title":"Welcome to the Programming Guide!"},{"location":"Basic - Code Structure/","text":"Overview Our team uses a CommandBase Code structure. Subsystems create objects required to control the robot. Inside the subsystems, methods execute specific tasks. Commands are made to then run the method. Understanding the code structure is the key to success Code Structure General Files Constants.java - Contains specific robot values (example: wheel diameters, calibration values, etcc) Main.java - All java programs start from main. This main file starts Robot.java Robot.java RobotContainer.java Creates robots subsystems Assign commands to controller buttons Command files - Requests action from subsystem files Subsystem files - Contain all possible actions of the subsystem Program Flow Example Program flow The command DropBall is assigned to controller button A on controller 1. When pressed, it will run the command DropBall located in Dropball.java. The command DropBall, represented by DropBall.java calls a method from subsystem GripperSubsystem, which was initalized and named m_GripperSubsystem in the RobotContainer.java The method GripperClose() in the subsystem GripperSubsystem contains the code that controls the solenoid, causing it to actuate.","title":"Code Structure"},{"location":"Basic - Code Structure/#overview","text":"Our team uses a CommandBase Code structure. Subsystems create objects required to control the robot. Inside the subsystems, methods execute specific tasks. Commands are made to then run the method. Understanding the code structure is the key to success","title":"Overview"},{"location":"Basic - Code Structure/#code-structure","text":"General Files Constants.java - Contains specific robot values (example: wheel diameters, calibration values, etcc) Main.java - All java programs start from main. This main file starts Robot.java Robot.java RobotContainer.java Creates robots subsystems Assign commands to controller buttons Command files - Requests action from subsystem files Subsystem files - Contain all possible actions of the subsystem","title":"Code Structure"},{"location":"Basic - Code Structure/#program-flow","text":"","title":"Program Flow"},{"location":"Basic - Code Structure/#example-program-flow","text":"The command DropBall is assigned to controller button A on controller 1. When pressed, it will run the command DropBall located in Dropball.java. The command DropBall, represented by DropBall.java calls a method from subsystem GripperSubsystem, which was initalized and named m_GripperSubsystem in the RobotContainer.java The method GripperClose() in the subsystem GripperSubsystem contains the code that controls the solenoid, causing it to actuate.","title":"Example Program flow"},{"location":"Basic - Commands/","text":"Overview Commands are used to execute robot functions. Commands call methods of subsystems to execute a task. Creating Commands To create a command, right click subsystems in the explorer and select Create a new class/command . Select command , and then name the command appropriately using CamelCase. For example, the command to stop an elevator should be named StopElevator . When you are done, a new .java file will be created under command. Requiring Subsystems The next thing to think about is if your command requires a subsystem. A command the requires a subsystem will automatically interrupt any other command that subsystem is running if needed. Example: What happens if raiseElevatorCommand is run the same time as lowerElevatorCommand ? To ensure both never run at the same time, we should require the subsystem for both commands. If this command requires control of the subsystem, add the following code under the constructor, public COMMANDNAME() Under the class: final <subsystem><subsystem name>; Under the constructor: <subsystem name> = subsystem; addRequirements(subsystem); Example: Calling Subsystem Methods The command requests the subsystem to perform a function, such as turn on a motor. For example, the following code will call on subsystem Elevator , and it's method stopElevator using the following code: <subsystem name>.<method name>(); The next question is, where should this code be placed? See the next section for details. Code Placement protected void initialize() - Code placed here will one run once when the command is run protected void execute() - Code placed here will run continously as long as the command is running protected void isFinished() - Code placed here determines when the command stops protected void end() - Code placed here runs once the command is over protected void interrupted() - Code placed here runs if the commands is interrupted by another command that requires the subsystem. Most of the time, you should run the end() command in this method.","title":"Programming Commmands"},{"location":"Basic - Commands/#overview","text":"Commands are used to execute robot functions. Commands call methods of subsystems to execute a task.","title":"Overview"},{"location":"Basic - Commands/#creating-commands","text":"To create a command, right click subsystems in the explorer and select Create a new class/command . Select command , and then name the command appropriately using CamelCase. For example, the command to stop an elevator should be named StopElevator . When you are done, a new .java file will be created under command.","title":"Creating Commands"},{"location":"Basic - Commands/#requiring-subsystems","text":"The next thing to think about is if your command requires a subsystem. A command the requires a subsystem will automatically interrupt any other command that subsystem is running if needed. Example: What happens if raiseElevatorCommand is run the same time as lowerElevatorCommand ? To ensure both never run at the same time, we should require the subsystem for both commands. If this command requires control of the subsystem, add the following code under the constructor, public COMMANDNAME() Under the class: final <subsystem><subsystem name>; Under the constructor: <subsystem name> = subsystem; addRequirements(subsystem); Example:","title":"Requiring Subsystems"},{"location":"Basic - Commands/#calling-subsystem-methods","text":"The command requests the subsystem to perform a function, such as turn on a motor. For example, the following code will call on subsystem Elevator , and it's method stopElevator using the following code: <subsystem name>.<method name>(); The next question is, where should this code be placed? See the next section for details.","title":"Calling Subsystem Methods"},{"location":"Basic - Commands/#code-placement","text":"protected void initialize() - Code placed here will one run once when the command is run protected void execute() - Code placed here will run continously as long as the command is running protected void isFinished() - Code placed here determines when the command stops protected void end() - Code placed here runs once the command is over protected void interrupted() - Code placed here runs if the commands is interrupted by another command that requires the subsystem. Most of the time, you should run the end() command in this method.","title":"Code Placement"},{"location":"Basic - Controllers/","text":"Overview Controllers are operated by human players in order to command the robot. In this section, you will create the controller and button objects in Java. If you have completed the command section , you can then assign commands to specific button. 1. Creating a Joystick Object The example below declares to the program that there is an object named that is a XBoxController . This should be placed under public class OI . The port number tells the computer which USB slot this controller should be in. XboxController <controllername> = new XboxController(0); 2. Creating Button Objects In the example above, we create a button on a xbox controller named <controllerName> . Note: Joysticks and the trigger are NOT considered buttons since their value can vary between 0 and 1 Syntax new JoystickButton(<controllername>, <buttontype>) Button Description Example kA A button new JoystickButton(Controller1,button.kA.value) kB B button new JoystickButton(Controller1,button.kB.value) kX X button new JoystickButton(Controller1,button.kX.value) kY Y button new JoystickButton(Controller1,button.kY.value) kBack Back button new JoystickButton(Controller1,button.kBack.value) kStart Start button new JoystickButton(Controller1,button.kStart.value) kBumperLeft Left Bumper new JoystickButton(Controller1,button.kBumperLeft.value) kBumperRight Right Bumper new JoystickButton(Controller1,button.kBumperRight.value) kStickLeft Left stick press new JoystickButton(Controller1,button.kStickLeft.value) kStickRight Right stick press new JoystickButton(Controller1,button.kStickRight.value) 3. Assigning Commands to Buttons NOTE: To complete this section, you must have completed the command section of the is guide. Depending on your design, you may want your buttons to behave differently. Here are 3 possible button types you can use, depending on your application. Add this immediately after you have created your button object. whenPressed Command starts when button is pressed, and it runs until the command's isFinished() method is satisfied. .whenPressed(new ExampleCommand()); whileHeld (Most Common) Command runs while button is held down, and is interrupted once the button is released. Note that interrupting a command does NOT automatically end it! You will need to modify the interrupted() method in the command by anding end(); to make sure it stops. .whileHeld(new ExampleCommand()); whenReleased Start command when button is released, and run until the command's isFinished() method is satisfied. .whenReleased(new ExampleCommand()); ExampleCommand","title":"Programming the Controller"},{"location":"Basic - Controllers/#overview","text":"Controllers are operated by human players in order to command the robot. In this section, you will create the controller and button objects in Java. If you have completed the command section , you can then assign commands to specific button.","title":"Overview"},{"location":"Basic - Controllers/#1-creating-a-joystick-object","text":"The example below declares to the program that there is an object named that is a XBoxController . This should be placed under public class OI . The port number tells the computer which USB slot this controller should be in. XboxController <controllername> = new XboxController(0);","title":"1. Creating a Joystick Object"},{"location":"Basic - Controllers/#2-creating-button-objects","text":"In the example above, we create a button on a xbox controller named <controllerName> . Note: Joysticks and the trigger are NOT considered buttons since their value can vary between 0 and 1 Syntax new JoystickButton(<controllername>, <buttontype>) Button Description Example kA A button new JoystickButton(Controller1,button.kA.value) kB B button new JoystickButton(Controller1,button.kB.value) kX X button new JoystickButton(Controller1,button.kX.value) kY Y button new JoystickButton(Controller1,button.kY.value) kBack Back button new JoystickButton(Controller1,button.kBack.value) kStart Start button new JoystickButton(Controller1,button.kStart.value) kBumperLeft Left Bumper new JoystickButton(Controller1,button.kBumperLeft.value) kBumperRight Right Bumper new JoystickButton(Controller1,button.kBumperRight.value) kStickLeft Left stick press new JoystickButton(Controller1,button.kStickLeft.value) kStickRight Right stick press new JoystickButton(Controller1,button.kStickRight.value)","title":"2. Creating Button Objects"},{"location":"Basic - Controllers/#3-assigning-commands-to-buttons","text":"NOTE: To complete this section, you must have completed the command section of the is guide. Depending on your design, you may want your buttons to behave differently. Here are 3 possible button types you can use, depending on your application. Add this immediately after you have created your button object.","title":"3. Assigning Commands to Buttons"},{"location":"Basic - Controllers/#whenpressed","text":"Command starts when button is pressed, and it runs until the command's isFinished() method is satisfied. .whenPressed(new ExampleCommand());","title":"whenPressed"},{"location":"Basic - Controllers/#whileheld-most-common","text":"Command runs while button is held down, and is interrupted once the button is released. Note that interrupting a command does NOT automatically end it! You will need to modify the interrupted() method in the command by anding end(); to make sure it stops. .whileHeld(new ExampleCommand());","title":"whileHeld (Most Common)"},{"location":"Basic - Controllers/#whenreleased","text":"Start command when button is released, and run until the command's isFinished() method is satisfied. .whenReleased(new ExampleCommand());","title":"whenReleased"},{"location":"Basic - Controllers/#examplecommand","text":"","title":"ExampleCommand"},{"location":"Basic - Conventions/","text":"Overview For the FIRST Robotics competition, the team will use the programming language Java . There are several rules we keep to try to keep our code clean and working. Programming Guidelines Comment your code Anything after // or surrounded by /* and */ is ignored by the program and will turn green. Use this to explain sections of code. Name objects appropriately in CamelCase All objects should be named CamelCase, where the first letter of each word is capitalized: Name methods appropriately in CamelCase starting with a lowercase For a method that raises the elevator, the first leter should be lowercase: raiseElevator No spaces in names Java doesnt like spaces. All statements must end with ; Statements are code that executes an action Blocks of code are contained within brackets { } . You can have blocks of code within blocks of code! In the below example, the colored circles mark the beginning { and ending } of each block of code. Note that the yellow and green blocks of code are within the red block of code, meaning that they may be run if the red block of code is run! The blue block of code is completely seperate.","title":"Programming Conventions"},{"location":"Basic - Conventions/#overview","text":"For the FIRST Robotics competition, the team will use the programming language Java . There are several rules we keep to try to keep our code clean and working.","title":"Overview"},{"location":"Basic - Conventions/#programming-guidelines","text":"Comment your code Anything after // or surrounded by /* and */ is ignored by the program and will turn green. Use this to explain sections of code. Name objects appropriately in CamelCase All objects should be named CamelCase, where the first letter of each word is capitalized: Name methods appropriately in CamelCase starting with a lowercase For a method that raises the elevator, the first leter should be lowercase: raiseElevator No spaces in names Java doesnt like spaces. All statements must end with ; Statements are code that executes an action Blocks of code are contained within brackets { } . You can have blocks of code within blocks of code! In the below example, the colored circles mark the beginning { and ending } of each block of code. Note that the yellow and green blocks of code are within the red block of code, meaning that they may be run if the red block of code is run! The blue block of code is completely seperate.","title":"Programming Guidelines"},{"location":"Basic - Subsystems/","text":"Overview Subsystems represent a major component of the robot, such as the drivetrain, an arm, or a shooter. The methods (or functions) within a subsystem control specific motors. In this section, you will create a subsytem and create actuator/sensor objects. You will then create the methods that control these components. Creating Subsystems To create a subsystem, right click subsystems in the explorer and select Create a new class/command . Select subsystem , and then name the subsystem using CamelCase, and suffixing with \"Subsystem\" Example : ElevatorSubsystem After you are done, a .java file will be created under the subsystems folder corresponding with the name chosen. The next step is to make sure when the Robot is initalized, the subsystem object is created. To do this, modify the RobotContainer.java with the following code and place this under the class declaration. private final <Subsystem_Name> m_<Subsystem_Name> = new <Subsystem_Name>(); Your end result should look similar to the following, but specific to your robot: Default Commands - Do I need one? Each subsystem can be assigned a default command. If a subsystem is not running anything, the default command will always be run. When would you want this? When you want something to always be running by default. For example, our drivetrain command always runs a DefaultDrive command that constantly checks to see if the joystick value has changed. If you need to have a default command, add the following code in the constructor of RobotContainer: <subsystemname>.setDefaultCommand(new command)); Example: Creating Actuator/Sensor Objects Actuators and sensors belong to the subsystem, and varies depending on design. In our example, an elevator may be controlled by a motor controller and an encoder . Every object must be created in the subsystem before it can be used. See Specialized Robot Code section for additional details.","title":"Programming Subsystems"},{"location":"Basic - Subsystems/#overview","text":"Subsystems represent a major component of the robot, such as the drivetrain, an arm, or a shooter. The methods (or functions) within a subsystem control specific motors. In this section, you will create a subsytem and create actuator/sensor objects. You will then create the methods that control these components.","title":"Overview"},{"location":"Basic - Subsystems/#creating-subsystems","text":"To create a subsystem, right click subsystems in the explorer and select Create a new class/command . Select subsystem , and then name the subsystem using CamelCase, and suffixing with \"Subsystem\" Example : ElevatorSubsystem After you are done, a .java file will be created under the subsystems folder corresponding with the name chosen. The next step is to make sure when the Robot is initalized, the subsystem object is created. To do this, modify the RobotContainer.java with the following code and place this under the class declaration. private final <Subsystem_Name> m_<Subsystem_Name> = new <Subsystem_Name>(); Your end result should look similar to the following, but specific to your robot:","title":"Creating Subsystems"},{"location":"Basic - Subsystems/#default-commands-do-i-need-one","text":"Each subsystem can be assigned a default command. If a subsystem is not running anything, the default command will always be run. When would you want this? When you want something to always be running by default. For example, our drivetrain command always runs a DefaultDrive command that constantly checks to see if the joystick value has changed. If you need to have a default command, add the following code in the constructor of RobotContainer: <subsystemname>.setDefaultCommand(new command)); Example:","title":"Default Commands - Do I need one?"},{"location":"Basic - Subsystems/#creating-actuatorsensor-objects","text":"Actuators and sensors belong to the subsystem, and varies depending on design. In our example, an elevator may be controlled by a motor controller and an encoder . Every object must be created in the subsystem before it can be used. See Specialized Robot Code section for additional details.","title":"Creating Actuator/Sensor Objects"},{"location":"Special - Camera/","text":"Overview A camera is used to provide vision to the driver. The camera is connected directly to the RoboRio via USB port. Importing You will need to import some existing libraries to utilize the camera. This will go at the top of Robot.java along with the other imports. import edu.wpi.first.wpilibj.CameraServer; import edu.wpi.first.wpilibj.IterativeRobot; Adding a Camera You will want to place this code when the Robot first starts up. Hint: The first file run is Robot.java . What method within this file is run first? Declaration & Start Recording USBCamera CAMERANAME = CameraServer.getInstance().startAutomaticCapture(); Change Resolution and Frame Rate There is a limit on wireless bandwidth, so one MAY need to adjust quality and frame rate (FPS). camera1.setResolution(320, 240); camera1.setFPS(10);","title":"Camera"},{"location":"Special - Camera/#overview","text":"A camera is used to provide vision to the driver. The camera is connected directly to the RoboRio via USB port.","title":"Overview"},{"location":"Special - Camera/#importing","text":"You will need to import some existing libraries to utilize the camera. This will go at the top of Robot.java along with the other imports. import edu.wpi.first.wpilibj.CameraServer; import edu.wpi.first.wpilibj.IterativeRobot;","title":"Importing"},{"location":"Special - Camera/#adding-a-camera","text":"You will want to place this code when the Robot first starts up. Hint: The first file run is Robot.java . What method within this file is run first?","title":"Adding a Camera"},{"location":"Special - Camera/#declaration-start-recording","text":"USBCamera CAMERANAME = CameraServer.getInstance().startAutomaticCapture();","title":"Declaration &amp; Start Recording"},{"location":"Special - Camera/#change-resolution-and-frame-rate","text":"There is a limit on wireless bandwidth, so one MAY need to adjust quality and frame rate (FPS). camera1.setResolution(320, 240); camera1.setFPS(10);","title":"Change Resolution and Frame Rate"},{"location":"Special - Motors/","text":"Overview Motor controllers control motors by sending controlled levels of voltage to a motor. In this section, you will learn to and create motor controller objects in Java. You will then create the methods that control these components. Creating a TalonSRX Object Place this in the class constructor under public class <Subsystem_name> extends SubsystemBase private final WPI_TalonSRX <motorcontrollername> = new WPI_TalonSRX(X); The number X corresponds to the CANId of the motor controller. Each motor controller has a unique CANId to make sure the correct one is called. Creating a VictorSP Object Place this under public class <Subsystem_name> extends SubsystemBase private final WPI_VictorSPX <motorcontrollername> = new WPI_VictorSPX(X); The number X corresponds to the CANId of the motor controller. Creating Motor Controller Methods A method is a function of the subsystem. Other parts of code can call the method, which will automatically run the block of code between the {}. This allows for code to be reused throughout the program. To create a method, place the following code before the final bracket. Be sure to name the method starting with a lowercase letter, then camelCase. public void <method_name>(){ } If you would like to pass a parameter into the method, use the following syntax. Multiple parameters can be passed if needed. public void <method_name>(<datatype> <parameter_name>){ } Methods should be placed at the bottom of the subsystem, but still contained within the class like so: Motor Controller Functions Each motor controler comes with a pre-built library of common functions. The most common are below: Methods Description Example set if control mode = PercentOutpuit, value of [-1,1] LeftElevatorMotor.set(1.0); setInverted switches rotation of motor (by default, positive values are counterclockwise, negative values are clockwise) LeftElevatorMotor.setInverted(true) stopMotor stops motor LeftElevatorMotor.stopmotor(); For a full description, see the following links TalonSRX API VictorSP API Example A function of an elevator may be to lift to a certain height, lower, or to stop. The motors controlling the elevator will push the elevator in a certain direction. To do the above, the following functions were created: This sets the elevator motor that we created earlier at a certain value. For example, to stop the elevator, we could call setElevator(0.0) to stop the elevator motors.","title":"Motor Controllers"},{"location":"Special - Motors/#overview","text":"Motor controllers control motors by sending controlled levels of voltage to a motor. In this section, you will learn to and create motor controller objects in Java. You will then create the methods that control these components.","title":"Overview"},{"location":"Special - Motors/#creating-a-talonsrx-object","text":"Place this in the class constructor under public class <Subsystem_name> extends SubsystemBase private final WPI_TalonSRX <motorcontrollername> = new WPI_TalonSRX(X); The number X corresponds to the CANId of the motor controller. Each motor controller has a unique CANId to make sure the correct one is called.","title":"Creating a TalonSRX Object"},{"location":"Special - Motors/#creating-a-victorsp-object","text":"Place this under public class <Subsystem_name> extends SubsystemBase private final WPI_VictorSPX <motorcontrollername> = new WPI_VictorSPX(X); The number X corresponds to the CANId of the motor controller.","title":"Creating a VictorSP Object"},{"location":"Special - Motors/#creating-motor-controller-methods","text":"A method is a function of the subsystem. Other parts of code can call the method, which will automatically run the block of code between the {}. This allows for code to be reused throughout the program. To create a method, place the following code before the final bracket. Be sure to name the method starting with a lowercase letter, then camelCase. public void <method_name>(){ } If you would like to pass a parameter into the method, use the following syntax. Multiple parameters can be passed if needed. public void <method_name>(<datatype> <parameter_name>){ } Methods should be placed at the bottom of the subsystem, but still contained within the class like so:","title":"Creating Motor Controller Methods"},{"location":"Special - Motors/#motor-controller-functions","text":"Each motor controler comes with a pre-built library of common functions. The most common are below: Methods Description Example set if control mode = PercentOutpuit, value of [-1,1] LeftElevatorMotor.set(1.0); setInverted switches rotation of motor (by default, positive values are counterclockwise, negative values are clockwise) LeftElevatorMotor.setInverted(true) stopMotor stops motor LeftElevatorMotor.stopmotor(); For a full description, see the following links TalonSRX API VictorSP API","title":"Motor Controller Functions"},{"location":"Special - Motors/#example","text":"A function of an elevator may be to lift to a certain height, lower, or to stop. The motors controlling the elevator will push the elevator in a certain direction. To do the above, the following functions were created: This sets the elevator motor that we created earlier at a certain value. For example, to stop the elevator, we could call setElevator(0.0) to stop the elevator motors.","title":"Example"},{"location":"Special - Pneumatics/","text":"Overview This page summarizes the overall steps required to program a pneumatic system. Pneumatics are controlled by the Pneumatic Control Module (PCM), which is wired to the pneumatic components. Like any other actuator, the compressor and pneumatic solenoid (the thing that controls the cylinder ) need to be declared. Each pneumatic component is controlled based on the node it is plugged in on the PCM (0-7), as seen below: Operating a compressor A compressor pumps air into the system. Instantiating a compressor The number corresponds with the PCM Node ID. Compressor COMPRESSORNAME = new Compressor(0); Starting a compressor COMPRESSORNAME.setClosedLoopControl(true); Stopping a compressor COMPRESSORNAME.setClosedLoopControl(false); Reading compressor status boolean enabled = COMPRESSORNAME.enabled //Checks if compressor is on boolean pressureSwitch = COMPRESSORNAME.getPressureSwitchValue(); //Check pressure switch value double current = COMPRESSORNAME.getCompressorCurrent(); //Check current of compressor Single Solenoids A single solenoid valve has one solenoid, and shifts when voltage is supplied to that solenoid. When voltage is removed, it shifts back to a \u201chome\u201d position. Solenoid exampleSolenoid = newSolenoid(1); exampleSolenoid.set(true); exampleSolenoid.set(false); The number corresponds with the Pneumatic Control Module (PCM) Node ID Double Solenoids A double solenoid has two solenoids, and when voltage is supplied to one (and not the other) the valve shifts. What this means is that the cylinder has no home position, so when power is cut, the valve will stay where it was at that time, and the cylinder will continue to do work in the direction is was working in Forward Channel - 1st channel, kforward Reverse channel - 2nd channel, kReverse DoubleSolenoid exampleDouble = new DoubleSolenoid(1, 2); exampleDouble.set(DoubleSolenoid.Value.kOff); exampleDouble.set(DoubleSolenoid.Value.kForward); exampleDouble.set(DoubleSolenoid.Value.kReverse); The number corresponds with the Pneumatic Control Module (PCM) Node ID","title":"Pneumatics"},{"location":"Special - Pneumatics/#overview","text":"This page summarizes the overall steps required to program a pneumatic system. Pneumatics are controlled by the Pneumatic Control Module (PCM), which is wired to the pneumatic components. Like any other actuator, the compressor and pneumatic solenoid (the thing that controls the cylinder ) need to be declared. Each pneumatic component is controlled based on the node it is plugged in on the PCM (0-7), as seen below:","title":"Overview"},{"location":"Special - Pneumatics/#operating-a-compressor","text":"A compressor pumps air into the system. Instantiating a compressor The number corresponds with the PCM Node ID. Compressor COMPRESSORNAME = new Compressor(0); Starting a compressor COMPRESSORNAME.setClosedLoopControl(true); Stopping a compressor COMPRESSORNAME.setClosedLoopControl(false);","title":"Operating a compressor"},{"location":"Special - Pneumatics/#reading-compressor-status","text":"boolean enabled = COMPRESSORNAME.enabled //Checks if compressor is on boolean pressureSwitch = COMPRESSORNAME.getPressureSwitchValue(); //Check pressure switch value double current = COMPRESSORNAME.getCompressorCurrent(); //Check current of compressor","title":"Reading compressor status"},{"location":"Special - Pneumatics/#single-solenoids","text":"A single solenoid valve has one solenoid, and shifts when voltage is supplied to that solenoid. When voltage is removed, it shifts back to a \u201chome\u201d position. Solenoid exampleSolenoid = newSolenoid(1); exampleSolenoid.set(true); exampleSolenoid.set(false); The number corresponds with the Pneumatic Control Module (PCM) Node ID","title":"Single Solenoids"},{"location":"Special - Pneumatics/#double-solenoids","text":"A double solenoid has two solenoids, and when voltage is supplied to one (and not the other) the valve shifts. What this means is that the cylinder has no home position, so when power is cut, the valve will stay where it was at that time, and the cylinder will continue to do work in the direction is was working in Forward Channel - 1st channel, kforward Reverse channel - 2nd channel, kReverse DoubleSolenoid exampleDouble = new DoubleSolenoid(1, 2); exampleDouble.set(DoubleSolenoid.Value.kOff); exampleDouble.set(DoubleSolenoid.Value.kForward); exampleDouble.set(DoubleSolenoid.Value.kReverse); The number corresponds with the Pneumatic Control Module (PCM) Node ID","title":"Double Solenoids"},{"location":"Special - Sensors/","text":"Overview Sensors are used to help the Robot understand the world around it. Using sensors, we can make robots react to the environment around them instead of depending on the driver to act. Here is sumamry of a few sensors we may use in the competition. Type Description Gyros Determines change in heading of the robot. Encoders Counts rotations of an axle. Typically used to count axle rotations to determine distance/velocity of the rotation Limit Switches Used for object detection. When in contact with an object, will send a different signal Ultrasonics Used to distance or object detection. Used only for short distances. Color sensor Used to determine color of an object. Gyros Gyros measure heading of the robot to determine what direction it is going in. 0 Degrees is defined as the angle the robot was facing when the gyro was last reset. Creating a Gyro object Place under public class <SUBSYSTEM> extends Subsystem . public static ADXRS450_Gyro GYRONAME = new ADXRS450_Gyro(); Usage Function | Description | Example usage ---------|-------------|-------------- getAngle()| get angle from gyro | <examplename>.getAngle(); reset()| reset gyro heading to zero | <examplename>.reset(); Encoders Encoders count the revolutions of an axle. By understanding how many times an axle/wheel rotates, we can estimate the distance traveled. AMT103-V - 5901's Drivetrain Encoder 5901 has used this encoder as a drivetrain encoder for years. Creating a AMT103-V Encoder Object place under public class <SUBSYSTEM> extends Subsystem public static Encoder <encodername> = new Encoder(0, 1, false, Encoder.EncodingType.k1X) ; Parameter Setting (to be placed in Constants.java static double diameter = MEASURE_THIS; // inches static double distancePerRev = diameter * Math.PI; static int ticksPerRev = 2048; // what you set them to , before was 2048 leftEncoder = new Encoder(0, 1, false, Encoder.EncodingType.k1X); leftEncoder.setDistancePerPulse(distancePerRev / ticksPerRev); leftEncoder.setReverseDirection(true); //Depends on if your mechanism runs counterclockwise or clockwise leftEncoder.setMaxPeriod(.1); leftEncoder.setMinRate(10); leftEncoder.setSamplesToAverage(7); CTRE Magnetic Encoder - 5901's Mechanism Encoder Creating on object None! CTRE encoders are wired directly into a TalonSRX, which serves as the object Parameter Setting TALONNAME.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0,0); TALONNAME.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0,0); //Set current position to 0 int sensorPos=0; elevatorEbony1.setSelectedSensorPosition(sensorPos, 0,10); elevatorEbony1.configOpenloopRamp(1.5,0); elevatorIvory7.configOpenloopRamp(1.5,0); elevatorIvory7.set(com.ctre.phoenix.motorcontrol.ControlMode.Follower, 1); elevatorEbony1.configForwardSoftLimitThreshold(36000,0); elevatorEbony1.configReverseSoftLimitThreshold(0,0); elevatorEbony1.configForwardSoftLimitEnable(true, 0); elevatorEbony1.configReverseSoftLimitEnable(true, 0); elevatorEbony1.configNominalOutputForward(0, 0); elevatorEbony1.configNominalOutputReverse(0, 0); elevatorIvory7.configNominalOutputForward(0, 0); elevatorIvory7.configNominalOutputReverse(0, 0); elevatorEbony1.configPeakOutputForward(.5,0); elevatorEbony1.configPeakOutputReverse(-.5,0); elevatorIvory7.configPeakOutputForward(.5,0); elevatorIvory7.configPeakOutputReverse(-.5,0); Limit Switch Creating a Limit Switch Object public static DigitalInput <LimitSwitchName> = new Digital Input (X) where X relates to the digital I/O port on the RoboRio. Ultrasonics How do ultrasonics work? Creating a ultrasonic object private static final int kUltrasonicPort = 0; // private static final double kValueToInches = 0.125; //Converts returned voltage to inches private final AnalogInput m_ultrasonic = new AnalogInput(kUltrasonicPort); Usage m_ultrasonic.getValue() * kValueToInches; // Converts signal to inches Color Sensor Creating a color sensor object private final I2C.Port i2cPort = i2C.Port.kOnboard; private final ColorSensorV3 m_colorSensor = new ColorSensorV3(i2cPort); private final ColorMatch m_colorMatcher = new ColorMatch(); Defining color calibrations Colors are defined by 3 numbers that define their Red/Green/Blue values (RGB). Use the following website to determine initial calibrations: RGB Calculator public static final Color kBlueTarget = ColorMatch.makeColor(0.136, 0.412, 0.450); public static final Color kGreenTarget = ColorMatch.makeColor(0.196, 0.557, 0.246); public static final Color kRedTarget = ColorMatch.makeColor(0.475, 0.371, 0.153); public static final Color kYellowTarget = ColorMatch.makeColor(0.293, 0.561, 0.144); Usage Adds the colors that the robot should matched based on the above colors m_colorMatcher.addColorMatch(kBlueTarget); m_colorMatcher.addColorMatch(kGreenTarget); m_colorMatcher.addColorMatch(kRedTarget); m_colorMatcher.addColorMatch(kYellowTarget); Color detectedColor = m_colorSensor.getColor(); String colorString; ColorMatchResult match = m_colorMatcher.matchClosestColor(detectedColor); if (match.color == kBlueTarget) { colorString = \"Blue\"; } else if (match.color == kRedTarget) { colorString = \"Red\"; } else if (match.color == kGreenTarget) { colorString = \"Green\"; } else if (match.color == kYellowTarget) { colorString = \"Yellow\"; } else { colorString = \"Unknown\"; } SmartDashboard.putNumber(\"Red\", detectedColor.red); SmartDashboard.putNumber(\"Green\", detectedColor.green); SmartDashboard.putNumber(\"Blue\", detectedColor.blue); SmartDashboard.putNumber(\"Confidence\", match.confidence); SmartDashboard.putString(\"Detected Color\", colorString);","title":"Sensors"},{"location":"Special - Sensors/#overview","text":"Sensors are used to help the Robot understand the world around it. Using sensors, we can make robots react to the environment around them instead of depending on the driver to act. Here is sumamry of a few sensors we may use in the competition. Type Description Gyros Determines change in heading of the robot. Encoders Counts rotations of an axle. Typically used to count axle rotations to determine distance/velocity of the rotation Limit Switches Used for object detection. When in contact with an object, will send a different signal Ultrasonics Used to distance or object detection. Used only for short distances. Color sensor Used to determine color of an object.","title":"Overview"},{"location":"Special - Sensors/#gyros","text":"Gyros measure heading of the robot to determine what direction it is going in. 0 Degrees is defined as the angle the robot was facing when the gyro was last reset. Creating a Gyro object Place under public class <SUBSYSTEM> extends Subsystem . public static ADXRS450_Gyro GYRONAME = new ADXRS450_Gyro(); Usage Function | Description | Example usage ---------|-------------|-------------- getAngle()| get angle from gyro | <examplename>.getAngle(); reset()| reset gyro heading to zero | <examplename>.reset();","title":"Gyros"},{"location":"Special - Sensors/#encoders","text":"Encoders count the revolutions of an axle. By understanding how many times an axle/wheel rotates, we can estimate the distance traveled. AMT103-V - 5901's Drivetrain Encoder 5901 has used this encoder as a drivetrain encoder for years. Creating a AMT103-V Encoder Object place under public class <SUBSYSTEM> extends Subsystem public static Encoder <encodername> = new Encoder(0, 1, false, Encoder.EncodingType.k1X) ; Parameter Setting (to be placed in Constants.java static double diameter = MEASURE_THIS; // inches static double distancePerRev = diameter * Math.PI; static int ticksPerRev = 2048; // what you set them to , before was 2048 leftEncoder = new Encoder(0, 1, false, Encoder.EncodingType.k1X); leftEncoder.setDistancePerPulse(distancePerRev / ticksPerRev); leftEncoder.setReverseDirection(true); //Depends on if your mechanism runs counterclockwise or clockwise leftEncoder.setMaxPeriod(.1); leftEncoder.setMinRate(10); leftEncoder.setSamplesToAverage(7); CTRE Magnetic Encoder - 5901's Mechanism Encoder Creating on object None! CTRE encoders are wired directly into a TalonSRX, which serves as the object Parameter Setting TALONNAME.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0,0); TALONNAME.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0,0); //Set current position to 0 int sensorPos=0; elevatorEbony1.setSelectedSensorPosition(sensorPos, 0,10); elevatorEbony1.configOpenloopRamp(1.5,0); elevatorIvory7.configOpenloopRamp(1.5,0); elevatorIvory7.set(com.ctre.phoenix.motorcontrol.ControlMode.Follower, 1); elevatorEbony1.configForwardSoftLimitThreshold(36000,0); elevatorEbony1.configReverseSoftLimitThreshold(0,0); elevatorEbony1.configForwardSoftLimitEnable(true, 0); elevatorEbony1.configReverseSoftLimitEnable(true, 0); elevatorEbony1.configNominalOutputForward(0, 0); elevatorEbony1.configNominalOutputReverse(0, 0); elevatorIvory7.configNominalOutputForward(0, 0); elevatorIvory7.configNominalOutputReverse(0, 0); elevatorEbony1.configPeakOutputForward(.5,0); elevatorEbony1.configPeakOutputReverse(-.5,0); elevatorIvory7.configPeakOutputForward(.5,0); elevatorIvory7.configPeakOutputReverse(-.5,0);","title":"Encoders"},{"location":"Special - Sensors/#limit-switch","text":"Creating a Limit Switch Object public static DigitalInput <LimitSwitchName> = new Digital Input (X) where X relates to the digital I/O port on the RoboRio.","title":"Limit Switch"},{"location":"Special - Sensors/#ultrasonics","text":"How do ultrasonics work? Creating a ultrasonic object private static final int kUltrasonicPort = 0; // private static final double kValueToInches = 0.125; //Converts returned voltage to inches private final AnalogInput m_ultrasonic = new AnalogInput(kUltrasonicPort); Usage m_ultrasonic.getValue() * kValueToInches; // Converts signal to inches","title":"Ultrasonics"},{"location":"Special - Sensors/#color-sensor","text":"Creating a color sensor object private final I2C.Port i2cPort = i2C.Port.kOnboard; private final ColorSensorV3 m_colorSensor = new ColorSensorV3(i2cPort); private final ColorMatch m_colorMatcher = new ColorMatch(); Defining color calibrations Colors are defined by 3 numbers that define their Red/Green/Blue values (RGB). Use the following website to determine initial calibrations: RGB Calculator public static final Color kBlueTarget = ColorMatch.makeColor(0.136, 0.412, 0.450); public static final Color kGreenTarget = ColorMatch.makeColor(0.196, 0.557, 0.246); public static final Color kRedTarget = ColorMatch.makeColor(0.475, 0.371, 0.153); public static final Color kYellowTarget = ColorMatch.makeColor(0.293, 0.561, 0.144); Usage Adds the colors that the robot should matched based on the above colors m_colorMatcher.addColorMatch(kBlueTarget); m_colorMatcher.addColorMatch(kGreenTarget); m_colorMatcher.addColorMatch(kRedTarget); m_colorMatcher.addColorMatch(kYellowTarget); Color detectedColor = m_colorSensor.getColor(); String colorString; ColorMatchResult match = m_colorMatcher.matchClosestColor(detectedColor); if (match.color == kBlueTarget) { colorString = \"Blue\"; } else if (match.color == kRedTarget) { colorString = \"Red\"; } else if (match.color == kGreenTarget) { colorString = \"Green\"; } else if (match.color == kYellowTarget) { colorString = \"Yellow\"; } else { colorString = \"Unknown\"; } SmartDashboard.putNumber(\"Red\", detectedColor.red); SmartDashboard.putNumber(\"Green\", detectedColor.green); SmartDashboard.putNumber(\"Blue\", detectedColor.blue); SmartDashboard.putNumber(\"Confidence\", match.confidence); SmartDashboard.putString(\"Detected Color\", colorString);","title":"Color Sensor"},{"location":"Special - Vision/","text":"Overview Vision can be used to aim the robot. It is most suitable to use when targets are easily distinguishable (bright yellow cubes, orange balls), or for games that have lots of vision targets. Implementing vision has two steps: Vision detection (easy) - Camera can detect the target reliably without confusing it with surrounding objects. Vision integration (hard) - Combining vision with the robot Team 5901 utilzes the Limelight Camera. Recommended Reading Link Description Mounting/Wiring/Imagine/Networking setup http://docs.limelightvision.io/en/latest/getting_started.html# Theory of how a vision processing works. Highly recommended to read to understand process. http://docs.limelightvision.io/en/latest/theory.html How to tune the limelight http://docs.limelightvision.io/en/latest/vision_pipeline_tuning.html Vision Code The vision subsystem code has been created in previous years and can be reused. Several methods were created that can be called by different commands, can be summarized in the following table: Method Name Description Example getTx() returns horizontal offset angle to camera m_VisionSubsystem.getTx(); getTy() returns vertical offset angle to camera m_VisionSubsystem.getTy(); getTa() returns target area, used to approximate distance to target) m_VisionSubsystem.getTa(); targetAvailable() returns a boolean if a target is detected m_VisionSubsystem.targetAvailable(); turnOffLED() turns off camera lights m_VisionSubsystem.turnOffLED(); turnOnLED() turns on camera lights m_VisionSubsystem.turnOnLED(); VisionSubsystem.java /*----------------------------------------------------------------------------*/ /* Copyright (c) 2019 FIRST. All Rights Reserved. */ /* Open Source Software - may be modified and shared by FRC teams. The code */ /* must be accompanied by the FIRST BSD license file in the root directory of */ /* the project. */ /*----------------------------------------------------------------------------*/ package frc.robot.subsystems; import edu.wpi.first.networktables.NetworkTable; import edu.wpi.first.networktables.NetworkTableEntry; import edu.wpi.first.networktables.NetworkTableInstance; import edu.wpi.first.wpilibj2.command.SubsystemBase; public class VisionSubsystem extends SubsystemBase { public VisionSubsystem() { } //Get Horizontal Offset Angle public double getTx(){ return NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"tx\").getDouble(0); } //Get Vertical Offset Angle public double getTy(){ return NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ty\").getDouble(0); } //Get Target Area public double getTa(){ return NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ta\").getDouble(0); } //Return true if target is available, otherwise false public boolean targetAvailable(){ if (NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"tv\").getDouble(0) < 1.0) { return false; } else { return true; } } public void turnOffLED(){ NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ledMode\").setNumber(1); } public void turnOnLED(){ NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ledMode\").setNumber(3); } @Override public void periodic() { // This method will be called once per scheduler run } }","title":"Vision"},{"location":"Special - Vision/#overview","text":"Vision can be used to aim the robot. It is most suitable to use when targets are easily distinguishable (bright yellow cubes, orange balls), or for games that have lots of vision targets. Implementing vision has two steps: Vision detection (easy) - Camera can detect the target reliably without confusing it with surrounding objects. Vision integration (hard) - Combining vision with the robot Team 5901 utilzes the Limelight Camera.","title":"Overview"},{"location":"Special - Vision/#recommended-reading","text":"Link Description Mounting/Wiring/Imagine/Networking setup http://docs.limelightvision.io/en/latest/getting_started.html# Theory of how a vision processing works. Highly recommended to read to understand process. http://docs.limelightvision.io/en/latest/theory.html How to tune the limelight http://docs.limelightvision.io/en/latest/vision_pipeline_tuning.html","title":"Recommended Reading"},{"location":"Special - Vision/#vision-code","text":"The vision subsystem code has been created in previous years and can be reused. Several methods were created that can be called by different commands, can be summarized in the following table: Method Name Description Example getTx() returns horizontal offset angle to camera m_VisionSubsystem.getTx(); getTy() returns vertical offset angle to camera m_VisionSubsystem.getTy(); getTa() returns target area, used to approximate distance to target) m_VisionSubsystem.getTa(); targetAvailable() returns a boolean if a target is detected m_VisionSubsystem.targetAvailable(); turnOffLED() turns off camera lights m_VisionSubsystem.turnOffLED(); turnOnLED() turns on camera lights m_VisionSubsystem.turnOnLED();","title":"Vision Code"},{"location":"Special - Vision/#visionsubsystemjava","text":"/*----------------------------------------------------------------------------*/ /* Copyright (c) 2019 FIRST. All Rights Reserved. */ /* Open Source Software - may be modified and shared by FRC teams. The code */ /* must be accompanied by the FIRST BSD license file in the root directory of */ /* the project. */ /*----------------------------------------------------------------------------*/ package frc.robot.subsystems; import edu.wpi.first.networktables.NetworkTable; import edu.wpi.first.networktables.NetworkTableEntry; import edu.wpi.first.networktables.NetworkTableInstance; import edu.wpi.first.wpilibj2.command.SubsystemBase; public class VisionSubsystem extends SubsystemBase { public VisionSubsystem() { } //Get Horizontal Offset Angle public double getTx(){ return NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"tx\").getDouble(0); } //Get Vertical Offset Angle public double getTy(){ return NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ty\").getDouble(0); } //Get Target Area public double getTa(){ return NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ta\").getDouble(0); } //Return true if target is available, otherwise false public boolean targetAvailable(){ if (NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"tv\").getDouble(0) < 1.0) { return false; } else { return true; } } public void turnOffLED(){ NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ledMode\").setNumber(1); } public void turnOnLED(){ NetworkTableInstance.getDefault().getTable(\"limelight\").getEntry(\"ledMode\").setNumber(3); } @Override public void periodic() { // This method will be called once per scheduler run } }","title":"VisionSubsystem.java"},{"location":"ToDo/","text":"To dos Figure out how to use axis Figure out autonomous Figure out smart dashboard Figure out talonsrx encoder","title":"To Dos"},{"location":"ToDo/#to-dos","text":"Figure out how to use axis Figure out autonomous Figure out smart dashboard Figure out talonsrx encoder","title":"To dos"},{"location":"about/","text":"To Do Sensors Electrical Wiring Vision","title":"About"},{"location":"about/#to-do","text":"Sensors Electrical Wiring Vision","title":"To Do"},{"location":"autonomous/","text":"Overview The first stage of the game usually involves an autonomus phase where Robots must act on their own without human intervention. The first exception to this rule is in 2019 - Deep Space. Declaration Command autonomousCommand; SendableChooser<Command> chooser = new SendableChooser<>(); Adding Autonomous Options You will need to add your autonomous commands to the SmartDashboard in order to choose between them. Place this code in the method that runs when the robot is first initialized within Robot.Java . chooser.addDefault(\"Autonomous Command\", new AutonomousCommand()); positionChooser.addDefault(\"Left\", \"left\"); positionChooser.addObject(\"Middle\", \"middle\"); positionChooser.addObject(\"Right\", \"right\"); positionChooser.addObject(\"Cross Line\", \"cross\"); SmartDashboard.putData(\"Auto Mode\", positionChooser); Run Autonomous Command Place this code where the autonomous phase is initalized within Robot.Java . public void autonomousInit() { autonomousCommand = new AUTONOMOUSCOMMANDNAME(); if (autonomousCommand != null) autonomousCommand.start();","title":"Autonomous (In Progress)"},{"location":"autonomous/#overview","text":"The first stage of the game usually involves an autonomus phase where Robots must act on their own without human intervention. The first exception to this rule is in 2019 - Deep Space.","title":"Overview"},{"location":"autonomous/#declaration","text":"Command autonomousCommand; SendableChooser<Command> chooser = new SendableChooser<>();","title":"Declaration"},{"location":"autonomous/#adding-autonomous-options","text":"You will need to add your autonomous commands to the SmartDashboard in order to choose between them. Place this code in the method that runs when the robot is first initialized within Robot.Java . chooser.addDefault(\"Autonomous Command\", new AutonomousCommand()); positionChooser.addDefault(\"Left\", \"left\"); positionChooser.addObject(\"Middle\", \"middle\"); positionChooser.addObject(\"Right\", \"right\"); positionChooser.addObject(\"Cross Line\", \"cross\"); SmartDashboard.putData(\"Auto Mode\", positionChooser);","title":"Adding Autonomous Options"},{"location":"autonomous/#run-autonomous-command","text":"Place this code where the autonomous phase is initalized within Robot.Java . public void autonomousInit() { autonomousCommand = new AUTONOMOUSCOMMANDNAME(); if (autonomousCommand != null) autonomousCommand.start();","title":"Run Autonomous Command"},{"location":"design/","text":"Overview This page summarizes the overall steps required to program a robot. Design Phase Strategy - What is the team strategy for autonomous mode? Subsystems What subsystems will you have on your robot? What does each subsystem need to do? What sensors should be used, if any? How many actuators does each subsystem need? Controllers How many controllers is needed to control this robot? What commands should be mapped to which buttons? Programming Phase Create Subsystem Classes Create objects Create methods to execute tasks control Create commands that utilize methods Autonomous routines need to be created Testing Test code & fix bugs Look for new ways to do things smarter and more efficiently Golden Rule: Your code doesnt work until you've tested it on the robot Example Lets say the team decides to build a robot that uses a gripper to squeeze a ball, then uses an elevator to raise the ball. Design Phase Programming Phase Need to create the following subsystems with the following objects Subsystems Drivetrain motor controller encoder gyro Elevator motor controller encoder Gripper solenoid compressor After, the following commands need to be created for the corresponding subsystem Commands Drivetrain Autonomous Drive Straight Elevator Raise Elevator Lower Elevator Stop Elevator Gripper Squeeze Ball Drop Ball Now that the robot structure is outlined, we can begin to code. Refer to the Basic Robot Programming page","title":"FRC Programming Outline"},{"location":"design/#overview","text":"This page summarizes the overall steps required to program a robot.","title":"Overview"},{"location":"design/#design-phase","text":"Strategy - What is the team strategy for autonomous mode? Subsystems What subsystems will you have on your robot? What does each subsystem need to do? What sensors should be used, if any? How many actuators does each subsystem need? Controllers How many controllers is needed to control this robot? What commands should be mapped to which buttons?","title":"Design Phase"},{"location":"design/#programming-phase","text":"Create Subsystem Classes Create objects Create methods to execute tasks control Create commands that utilize methods Autonomous routines need to be created","title":"Programming Phase"},{"location":"design/#testing","text":"Test code & fix bugs Look for new ways to do things smarter and more efficiently Golden Rule: Your code doesnt work until you've tested it on the robot","title":"Testing"},{"location":"design/#example","text":"Lets say the team decides to build a robot that uses a gripper to squeeze a ball, then uses an elevator to raise the ball.","title":"Example"},{"location":"design/#design-phase_1","text":"","title":"Design Phase"},{"location":"design/#programming-phase_1","text":"Need to create the following subsystems with the following objects Subsystems Drivetrain motor controller encoder gyro Elevator motor controller encoder Gripper solenoid compressor After, the following commands need to be created for the corresponding subsystem Commands Drivetrain Autonomous Drive Straight Elevator Raise Elevator Lower Elevator Stop Elevator Gripper Squeeze Ball Drop Ball Now that the robot structure is outlined, we can begin to code. Refer to the Basic Robot Programming page","title":"Programming Phase"},{"location":"java/","text":"Overview The programing language Team 5901 uses is Java. The goal is to provide students basic Java knowledge to survive build season. This is NOT a comprehensive guide on Java - refer to online guides for a more detailed guide, Commenting code Comments can be used to document code, but can also be used to ignore parts of code. Single-line comments start with two forward slashes (//). Multi-line comments start with /* and ends with */. // This is a comment System.out.println(\"Hello World\"); /* everything between these are comments also part of a comment */ Variables & Data Types In Java, variables store data values. Different data values are represented by different Data Types . Data types represent different kinds of variables. Some variables store numbers, other stores text, etc. To create a variable, the following syntax is used: <type> <variable name> = <value>; A few of the common ones we will use can be seen below: Data Type Description Example Declaration int stores integers int age = 5; double stores fractional numbers double cost = 3.5; boolean stores true or false boolean LightOn = true; String Stores text, surrounded by double quotes String Name = \"Cougar Pack\"; Math Functions Sometimes, our algorithm will require us to make calculations. Here are some common functionss we may use: Function Description Example Usage Math.max(x,y) returns the maximum of x and y Math.max(20,5) would be return as 20 Math.min(x,y) returns the minimum of x and y Math.min(20,5) would be return as 5 Math.sqrt(x) returns the square root of x Math.sqrrt(100) would be return as 10 Math.abs(x) reutnrs absolute value of x Math.abs(-100) would return 100 Operators Operators perform operations on variables and values. Here are some common operators we may use: Arithmetic Operators Operator Description Example Usage + addition 5+3 returns 8 - subtraction 5 - 3 returns 2 * multiplication 5* 3 returns 15 / division 5/3 returns 1.66 % modulous (remainder) 5%3 returns 2 Comparison Operators Comparison operators compare two values. The result is returned as a boolean (true or false) Operator Description Example Usage == Equal to 5 == 3 would return false != Not Equal 5 != 3 would return true > Greater than 5 > 3 would return true. 5 > 5 would return false. < Less than 5 < 3 would return false. 5 < 3 would return false. >= Greater than or equal to 5 >= 3 would return true. 5 >= 5 would return true. <= Less than or equal to 5 < 3 would return false. 5 <= 5 would return true. Comparison Operators Logical operators are used to determine logic between variables Operator Description Example Usage && AND - returns true if both statements are true (5 > 3) && (6 > 6) would return false & & ! NOT - returns true if false, return false if true !(5 > 3) would return false If-else If-elses are used for control logic if (condition1) { } else if (condition2) { } else { } Example: int grade = 75; if (grade > 90){ system.out.println(\"Grade is an A\"); } else if (grade > 80){ system.out.println(\"Grade is an B\"); } else if (grade > 70){ system.out.println(\"Grade is an C\"); } else if (grade > 60){ system.out.println(\"Grade is an D\"); } else { system.out.println(\"Grade is an F\"); } Methods A method is a block of code which only runs when it is called. Arugments can be passed into methods, similiarly to a math function such as f(x) = 5x, where different values of x can be passed for different answers. This allows methods to be reused - you dont need seperate lines of code for controlling different motor speeds! Syntax public <return type> <method name>(datatype argument){ } In the following example, the method below can be used to make a robot drive forward, drive backwards, OR stop completely! Example public void elevatorMove(double power){ elevatorMotor(power); System.out.println(\"Running elevator at\" + power; } Later, this method can be called in multiple ways to have different functions: arcadeDrive(1.0) // robot drives forward arcadeDrive (0.0) // robot stops arcadeDrive(-1.0) // robot drives backwards This is equivalent to running the following: elevatorMotorPower(1.0); System.out.println(\"Running elevator at\" + 1.0); elevatorMotor(0.0); System.out.println(\"Running elevator at\" + 0.0); elevatorMotor(-1.0); System.out.println(\"Running elevator at\" + -1.0);","title":"FRC Java Basics"},{"location":"java/#overview","text":"The programing language Team 5901 uses is Java. The goal is to provide students basic Java knowledge to survive build season. This is NOT a comprehensive guide on Java - refer to online guides for a more detailed guide,","title":"Overview"},{"location":"java/#commenting-code","text":"Comments can be used to document code, but can also be used to ignore parts of code. Single-line comments start with two forward slashes (//). Multi-line comments start with /* and ends with */. // This is a comment System.out.println(\"Hello World\"); /* everything between these are comments also part of a comment */","title":"Commenting code"},{"location":"java/#variables-data-types","text":"In Java, variables store data values. Different data values are represented by different Data Types . Data types represent different kinds of variables. Some variables store numbers, other stores text, etc. To create a variable, the following syntax is used: <type> <variable name> = <value>; A few of the common ones we will use can be seen below: Data Type Description Example Declaration int stores integers int age = 5; double stores fractional numbers double cost = 3.5; boolean stores true or false boolean LightOn = true; String Stores text, surrounded by double quotes String Name = \"Cougar Pack\";","title":"Variables &amp; Data Types"},{"location":"java/#math-functions","text":"Sometimes, our algorithm will require us to make calculations. Here are some common functionss we may use: Function Description Example Usage Math.max(x,y) returns the maximum of x and y Math.max(20,5) would be return as 20 Math.min(x,y) returns the minimum of x and y Math.min(20,5) would be return as 5 Math.sqrt(x) returns the square root of x Math.sqrrt(100) would be return as 10 Math.abs(x) reutnrs absolute value of x Math.abs(-100) would return 100","title":"Math Functions"},{"location":"java/#operators","text":"Operators perform operations on variables and values. Here are some common operators we may use:","title":"Operators"},{"location":"java/#arithmetic-operators","text":"Operator Description Example Usage + addition 5+3 returns 8 - subtraction 5 - 3 returns 2 * multiplication 5* 3 returns 15 / division 5/3 returns 1.66 % modulous (remainder) 5%3 returns 2","title":"Arithmetic Operators"},{"location":"java/#comparison-operators","text":"Comparison operators compare two values. The result is returned as a boolean (true or false) Operator Description Example Usage == Equal to 5 == 3 would return false != Not Equal 5 != 3 would return true > Greater than 5 > 3 would return true. 5 > 5 would return false. < Less than 5 < 3 would return false. 5 < 3 would return false. >= Greater than or equal to 5 >= 3 would return true. 5 >= 5 would return true. <= Less than or equal to 5 < 3 would return false. 5 <= 5 would return true.","title":"Comparison Operators"},{"location":"java/#comparison-operators_1","text":"Logical operators are used to determine logic between variables Operator Description Example Usage && AND - returns true if both statements are true (5 > 3) && (6 > 6) would return false & & ! NOT - returns true if false, return false if true !(5 > 3) would return false","title":"Comparison Operators"},{"location":"java/#if-else","text":"If-elses are used for control logic if (condition1) { } else if (condition2) { } else { } Example: int grade = 75; if (grade > 90){ system.out.println(\"Grade is an A\"); } else if (grade > 80){ system.out.println(\"Grade is an B\"); } else if (grade > 70){ system.out.println(\"Grade is an C\"); } else if (grade > 60){ system.out.println(\"Grade is an D\"); } else { system.out.println(\"Grade is an F\"); }","title":"If-else"},{"location":"java/#methods","text":"A method is a block of code which only runs when it is called. Arugments can be passed into methods, similiarly to a math function such as f(x) = 5x, where different values of x can be passed for different answers. This allows methods to be reused - you dont need seperate lines of code for controlling different motor speeds! Syntax public <return type> <method name>(datatype argument){ } In the following example, the method below can be used to make a robot drive forward, drive backwards, OR stop completely! Example public void elevatorMove(double power){ elevatorMotor(power); System.out.println(\"Running elevator at\" + power; } Later, this method can be called in multiple ways to have different functions: arcadeDrive(1.0) // robot drives forward arcadeDrive (0.0) // robot stops arcadeDrive(-1.0) // robot drives backwards This is equivalent to running the following: elevatorMotorPower(1.0); System.out.println(\"Running elevator at\" + 1.0); elevatorMotor(0.0); System.out.println(\"Running elevator at\" + 0.0); elevatorMotor(-1.0); System.out.println(\"Running elevator at\" + -1.0);","title":"Methods"},{"location":"update/","text":"Overview Every year, new software is released. Our robot electronics need to be updated to have the latest changes. Installing Java Development Environment We use the program VSCode to program our robot. This only needs to be done for new computers that do not have VSCode. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/999999-installing-c-and-java-development-tools-for-frc Installing FRC Update Suite FRC Suite includes all of the FRC specific updates for the season. You will need an NI account and the license key to complete this step. See lead mentor for this information. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/1004055-installing-the-frc-update-suite-all-languages Imaging RoboRio The RoboRio is the brain of the robot, and needs to be updated for the new season. To do this step, the computer must have the FRC Update Suite installed. The RoboRio must also be correctly powered to the Power Distribution Panel. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/1009233-imaging-your-roborio CTRE libraries and updating CAN Firmware To do this step, the electrical board must be completely wired. The CTRE library includes updates to software if you use TalonSRXs or Victor SPXs. http://www.ctr-electronics.com/control-system/hro.html#product_tabs_technical_resources Download and run the latest CTRE Pheonix Framework Installer. To install the web plugin, plug in the usb cable for imaging the RoboRio into the computer and Roborio. Open the Pheonix Tuner on the desktop, select roboRio upgrade tab, and select update Rio Web-based config To update the CAN software, we need to download the firmware from CTR. Download the latest Talon SRX Firmware. http://www.ctr-electronics.com/talon-srx.html#product_tabs_technical_resources After doing that, go to the CAN devices tab in the Pheonix Tuner. Select the firmware CRF file that you just downloaded, check the update all devices with matching type box, and then click update device. Assigning CAN IDs To do this step, the electrical board must be completely wired. Open the Pheonix Tuner from the desktop. Click on the CAN devices laptop. You can select CAN devices from this window. If none appear, then there is a wiring issue with the CAN bus At the bottom is a General Device Configuration window. Use this to change the ID of the motor controllers. Use the blink button to determine which controller is the one selected. Number the motor controllers based on the following 5901 convention: Left controllers - Odd numbers, from front to back (1,3,5,7, etc.) Right controllers - Even numbers, from front to back (2,4,6,8, etc.) Imaging Radio The Radio is how the laptop communicates to the Robot, and needs to be updated. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/144986-programming-your-radio","title":"Updating Hardware"},{"location":"update/#overview","text":"Every year, new software is released. Our robot electronics need to be updated to have the latest changes.","title":"Overview"},{"location":"update/#installing-java-development-environment","text":"We use the program VSCode to program our robot. This only needs to be done for new computers that do not have VSCode. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/999999-installing-c-and-java-development-tools-for-frc","title":"Installing Java Development Environment"},{"location":"update/#installing-frc-update-suite","text":"FRC Suite includes all of the FRC specific updates for the season. You will need an NI account and the license key to complete this step. See lead mentor for this information. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/1004055-installing-the-frc-update-suite-all-languages","title":"Installing FRC Update Suite"},{"location":"update/#imaging-roborio","text":"The RoboRio is the brain of the robot, and needs to be updated for the new season. To do this step, the computer must have the FRC Update Suite installed. The RoboRio must also be correctly powered to the Power Distribution Panel. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/1009233-imaging-your-roborio","title":"Imaging RoboRio"},{"location":"update/#ctre-libraries-and-updating-can-firmware","text":"To do this step, the electrical board must be completely wired. The CTRE library includes updates to software if you use TalonSRXs or Victor SPXs. http://www.ctr-electronics.com/control-system/hro.html#product_tabs_technical_resources Download and run the latest CTRE Pheonix Framework Installer. To install the web plugin, plug in the usb cable for imaging the RoboRio into the computer and Roborio. Open the Pheonix Tuner on the desktop, select roboRio upgrade tab, and select update Rio Web-based config To update the CAN software, we need to download the firmware from CTR. Download the latest Talon SRX Firmware. http://www.ctr-electronics.com/talon-srx.html#product_tabs_technical_resources After doing that, go to the CAN devices tab in the Pheonix Tuner. Select the firmware CRF file that you just downloaded, check the update all devices with matching type box, and then click update device.","title":"CTRE libraries and updating CAN Firmware"},{"location":"update/#assigning-can-ids","text":"To do this step, the electrical board must be completely wired. Open the Pheonix Tuner from the desktop. Click on the CAN devices laptop. You can select CAN devices from this window. If none appear, then there is a wiring issue with the CAN bus At the bottom is a General Device Configuration window. Use this to change the ID of the motor controllers. Use the blink button to determine which controller is the one selected. Number the motor controllers based on the following 5901 convention: Left controllers - Odd numbers, from front to back (1,3,5,7, etc.) Right controllers - Even numbers, from front to back (2,4,6,8, etc.)","title":"Assigning CAN IDs"},{"location":"update/#imaging-radio","text":"The Radio is how the laptop communicates to the Robot, and needs to be updated. https://wpilib.screenstepslive.com/s/currentCS/m/getting_started/l/144986-programming-your-radio","title":"Imaging Radio"}]}